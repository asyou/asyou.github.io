<!DOCTYPE html>
<html>
<head>
<title>Thinkphp5使用Workman搭建WebSocket即时聊天服务 - 王维的博客</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF" crossorigin="anonymous"></script>
<link href="../highlight/styles/a11y-dark.min.css" rel="stylesheet">
<script src="../highlight/highlight.min.js"></script>
<script >hljs.initHighlightingOnLoad();</script>
<style type="text/css">
    body {
        margin-top: 70px;
    }
    h1 {
        font-size: 18px;
    }
    h3 {
        font-size: 16px;
    }
    p {
        font-size: 14px;
    }
</style>
</head>
<body>
    <nav class="navbar navbar-expand-md bg-dark navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../index.html">王维的博客</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="collapsibleNavbar">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="../index.html">主页</a></li>
                    <li class="nav-item active"><a class="nav-link" href="../html/php.html">PHP</a></li>
                    <li class="nav-item"><a class="nav-link" href="../html/vue.html">Vue</a></li> 
                    <li class="nav-item"><a class="nav-link" href="../html/notes.html">随手笔记</a></li> 
                </ul>
            </div>
        </div>
    </nav>
    <div class="container">
        <div class="content mt-3">
            <h1>Thinkphp5使用Workman搭建WebSocket即时聊天服务</h1>
            <span class="date"><small>2022-03-01</small></span>
            <div class="mt-4">
                <h3>本文要实现的功能和流程</h3>
                <p>1、用户在网站或APP点击客服按钮，进入与客服实时聊天界面；</p>
                <p>2、如客服在线，则可以双向实时聊天；</p>
                <p>3、保存所有客服与客户的聊天记录到数据库；</p>
                <p>4、聊天内容同时通过个推推送给对方（App才有）。</p>
                <p style="color: red;">本文要实现的并非简单的“聊天室”功能，是需要用户登录的一对一聊天（或群聊），与无需登录的临时聊天实现逻辑不同。</p>
                <p>Thinkphp官方提供了Workman的扩展包，但经实际测试过于简单，无法实现我想要达到的功能，所以采用了GatewayWorker插件，官方网站：<a href="https://www.workerman.net/doc/gateway-worker/" target="_blank">点击前往</a>，Github地址：<a href="https://github.com/walkor/GatewayClient" target="_blank">点击前往</a>，推荐使用composer方式安装。</p>
                <h3>本文实例使用Thinkphp5作为服务端，前端使用uniapp作为用户端。</h3>
                <p>主要几个表的结构</p>
                <table class="table">
                    <thead class="thead-dark"><tr><th colspan="3">chat_group表结构，记录所有会话组</th></tr></thead>
                    <tr><th>主要字段</th><th>类型</th><th>注释</th></tr>
                    <tr><td>id</td><td>int(11)</td><td>自增ID</td></tr>
                    <tr><td>name</td><td>varchar(32)</td><td>会话组名称</td></tr>
                    <tr><td>user_id</td><td>int(11)</td><td>创建者ID</td></tr>
                    <tr><td>thumbnail</td><td>varchar(100)</td><td>会话组头像</td></tr>
                </table>
                <table class="table">
                    <thead class="thead-dark"><tr><th colspan="3">chat_group_user表结构，记录所有会话组的成员</th></tr></thead>
                    <tr><th>主要字段</th><th>类型</th><th>注释</th></tr>
                    <tr><td>id</td><td>int(11)</td><td>自增ID</td></tr>
                    <tr><td>chat_group_id</td><td>int(11)</td><td>会话组ID</td></tr>
                    <tr><td>user_id</td><td>int(11)</td><td>用户ID</td></tr>
                </table>
                <table class="table">
                    <thead class="thead-dark"><tr><th colspan="3">chat_client表结构，记录所有用户的client_id</th></tr></thead>
                    <tr><th>主要字段</th><th>类型</th><th>注释</th></tr>
                    <tr><td>id</td><td>int(11)</td><td>自增ID</td></tr>
                    <tr><td>client_id</td><td>varchar(32)</td><td>ClientID</td></tr>
                    <tr><td>user_id</td><td>int(11)</td><td>用户ID</td></tr>
                </table>
                <table class="table">
                    <thead class="thead-dark"><tr><th colspan="3">chat_content表结构，记录所有用户的聊天记录</th></tr></thead>
                    <tr><th>主要字段</th><th>类型</th><th>注释</th></tr>
                    <tr><td>id</td><td>int(11)</td><td>自增ID</td></tr>
                    <tr><td>chat_group_id</td><td>int(11)</td><td>会话组ID</td></tr>
                    <tr><td>user_id</td><td>int(11)</td><td>用户ID</td></tr>
                    <tr><td>content</td><td>varchar(500)</td><td>聊天内容</td></tr>
                </table>
                <p>先上服务端代码</p>
                <h3>一、在public/目录下新建server.php</h3>
<pre><code class="php">#!/usr/bin/env php
&lt?php
define('APP_PATH', __DIR__ . '/../application/');
define('BIND_MODULE','push/Index');
// 加载框架引导文件
require __DIR__ . '/../thinkphp/start.php';</code></pre>
                <h3>二、在application中新建push模块</h3>
                <p>在controller中创建Index.php和Events.php两个文件</p>
<pre><code class="php">// application/push/controller/Index.php
// 该文件内容由官方提供，只需要修改IP地址和控制器，其他保持默认（所有逻辑都在Events.php中实现）
&lt?php
namespace app\push\controller;
use \GatewayWorker\Register;
use \GatewayWorker\Gateway;
use \GatewayWorker\BusinessWorker;
use \Workerman\Worker;

class Index extends Worker
{
    public function __construct()
    {
        $ip = '127.0.0.1';
        // 初始化register
        new Register('text://'.$ip.':1238');
        // 初始化 bussinessWorker 进程
        $worker = new BusinessWorker();
        $worker->name = 'GatewayChat';
        $worker->count = 1;
        $worker->registerAddress = $ip.':1238';
        // 设置处理业务的类,此处制定Events的命名空间
        $worker->eventHandler = '\app\push\controller\Events';
        // 初始化 gateway 进程
        $gateway = new Gateway("websocket://".$ip.":1236");
        $gateway->name = 'push';
        $gateway->count = 1;
        $gateway->lanIp = $ip;
        $gateway->startPort = 2900;
        $gateway->pingInterval = 30;
        $gateway->pingNotResponseLimit = 1;
        $gateway->pingData = 'ping';
        $gateway->registerAddress = $ip.':1238';
        // 运行所有Worker;
        Worker::runAll();
    }
}</code></pre>
<pre><code class="php">// application/push/controller/Events.php
&lt?php
namespace app\push\controller;
use \think\Controller;
use \think\Db;
use \think\Config;
use \GatewayWorker\Lib\Gateway;
use \app\admin\model\chat\Group;
use \app\admin\model\chat\Content;

class Events extends Controller
{
    /**
     * 当客户端发来消息时触发
     * @param int $client_id 会话id
     * @param mixed $data 具体消息
     */
    public static function onMessage($client_id, $data)
    {
        $sysUserModel   = new \app\admin\model\User;
        $userModel      = new \app\admin\model\chat\User;     // 会话组用户
        $groupModel     = new \app\admin\model\chat\Group;    // 会话组表
        $clientModel    = new \app\admin\model\chat\Client;   // 会话ID表
        $contentModel   = new \app\admin\model\chat\Content;  // 会话内容表

        $arr = json_decode($data, true);
        switch($arr['type']) {
            case 'authorize':   // 首次连接，保存或更新用户client_id
                $check_user_client = $clientModel->where(['user_id'=>$arr['user_id']])->count();
                if ($check_user_client) {
                    $clientModel->save(['client_id'=>$client_id],['user_id'=>$arr['user_id']]);
                } else {
                    $clientModel->save(['client_id'=>$client_id,'user_id'=>$arr['user_id']]);
                }
                Gateway::bindUid($client_id,$arr['user_id']);
                break;
            case 'heartbeat':    // 心跳检测
                $rsp = [
                    'type' => 'heartbeat',
                    'msg'  => 'pong'
                ];
                Gateway::sendToClient($client_id,json_encode($rsp));
                break;
            case 'message':     // 接收到消息
                // 1、保存会话内容
                $contentModel->save(['chat_group_id'=>$arr['group_id'],'user_id'=>$arr['user_id'],'content'=>$arr['msg']]);
                $groupModel->where(['id'=>$arr['group_id']])->setInc('rows',1);
                $groupModel->save(['updatetime'=>time()],['id'=>$arr['group_id']]);
                // 2、获取会话组成员的client_id(除自己之外的所有用户)，并实时下发数据
                $group_users = $userModel
                    ->alias('a')
                    ->field(['b.user_id','b.client_id'])
                    ->join('__CHAT_CLIENT__ b','a.user_id=b.user_id')
                    ->where(['a.chat_group_id'=>$arr['group_id'],'a.user_id'=>['NEQ',$arr['user_id']]])
                    ->select()
                    ->toArray();
                // 3、获取用户的名称、头像等(自己的)
                $user = $sysUserModel
                    ->field(['nickname','realname','avatar','clientid'])
                    ->where(['id'=>$arr['user_id']])
                    ->find();
                $rsp = [
                    'type'      => 'message',
                    'user_id'   => $arr['user_id'],
                    'msg'       => $arr['msg'],
                    'username'  => $user['realname'],
                    'avatar'    => $user['avatar']
                ];
                if (count($group_users) > 0) {
                    // Gateway::sendToAll(json_encode($rsp),$clientIds = array_column($group_users,'client_id'));
                    Gateway::sendToUid(array_column($group_users,'user_id'),json_encode($rsp));
                    // 此处往下是个推App消息推送（用不上可删除）
                    $clients = [];
                    for ($i=0;$i&lt;count($group_users);$i++) {
                        $clientid = $sysUserModel->where(['id'=>$group_users[$i]['user_id']])->value('clientid');
                        // 如果有clientid，则放入数组
                        if ($clientid) array_push($clients,$clientid);
                    }
                    // 创建通知消息并获取taskid
                    $api = new \GTClient(Config::get('getui.ApiUrl'),Config::get('getui.AppKey'),Config::get('getui.AppId'),Config::get('getui.MasterSecret'));
                    $push = new \GTPushRequest();
                    $push->setRequestId(md5(time().mt_rand(1,9999999)));
                    $message = new \GTPushMessage();
                    $notify = new \GTNotification();
                    $notify->setTitle($user['realname']?$user['realname']:$user['nickname']);
                    $notify->setBody($rsp['msg']);
                    // 1、启动应用并进入首页
                    $notify->setClickType('startapp');

                    // 2、打开指定网页
                    // $notify->setClickType('url');
                    // $notify->setUrl('http://m.xxx.com');

                    // 3、离线透传消息（设置payload参数，APP自行接收处理后续业务）
                    // $notify->setClickType('intent');
                    // $notify->setIntent('intent:#Intent;action=android.intent.action.oppopush;launchFlags=0x14000000;component=com.xxx.app/io.dcloud.PandoraEntry;S.UP-OL-SU=true;S.title='.$title.';S.content='.$content.';S.payload='.json_encode($payload).';end');

                    // 4、纯通知，点击消息无后续动作
                    // $notify->setClickType('none');
                    $message->setNotification($notify);
                    $push->setPushMessage($message);
                    $task = $api->pushApi()->createListMsg($push);
                    // 通知消息群发
                    $audience = new \GTAudienceRequest();
                    $audience->setCidList($clients);
                    $audience->setTaskId($task['data']['taskid']);
                    $api->pushApi()->pushListByCid($audience);
                }
                break;
            case 'temporary':   // 临时会话消息
                $rsp = [
                    'type' => 'message',
                    'msg'  => $arr['msg']
                ];
                Gateway::sendToClient($arr['to_client_id'],json_encode($rsp));
                break;
        }
    }

    /**
     * 当客户端连接时触发
     * 如果业务不需此回调可以删除onConnect
     *
     * @param int $client_id 连接id
     */
    public static function onConnect($client_id) {}

    /**
     * 当连接断开时触发的回调函数
     * @param $connection
     */
    public static function onClose($client_id) {}

    /**
     * 当客户端的连接上发生错误时触发
     * @param $connection
     * @param $code
     * @param $msg
     */
    public static function onError($client_id, $code, $msg)
    {
        echo "error $code $msg\n";
    }

    /**
     * 每个进程启动
     * @param $worker
     */
    public static function onWorkerStart($worker) {}
}</code></pre>
                <h3>三、处理用户聊天数据</h3>
                <p>在API模块中创建Chat.php</p>
<pre><code class="php">// /application/api/controller/Chat.php
&lt?php
namespace app\api\controller;
use app\common\controller\Api;

/**
 * 聊天接口
 */
class Chat extends Api
{
    protected $noNeedLogin = [];
    protected $noNeedRight = ['*'];

    public function _initialize()
    {
        parent::_initialize();
        $this->userModel    = new \app\admin\model\chat\User;
        $this->groupModel   = new \app\admin\model\chat\Group;
        $this->clientModel  = new \app\admin\model\chat\Client;
        $this->contentModel = new \app\admin\model\chat\Content;
        $this->sysUserModel = new \app\admin\model\User;
    }

    /**
     * 加载聊天列表
     * @param integer $pages 页数
     * @param integer $limit 条数
     * @return array
     */
    public function index()
    {
        $params = $this->request->param();
        $limit = $params['limit'];
        $offset = ($params['pages']-1)*$limit;

        $data['list'] = $this->userModel
            ->alias('a')
            ->field(['b.id','b.user_id','b.name','b.thumbnail','b.status','b.createtime','b.updatetime'])
            ->join('__CHAT_GROUP__ b','a.chat_group_id=b.id')
            ->where(['a.user_id'=>$this->auth->id,'b.rows'=>['GT','0']])
            ->limit($offset,$limit)
            ->order(['b.updatetime'=>'DESC'])
            ->select();
        for ($i=0;$i&lt;count($data['list']);$i++) {
            // 处理群聊头像和群名称
            $checkChat = $this->userModel->where(['chat_group_id'=>$data['list'][$i]['id']])->count();
            if ($checkChat <= 2) {
                // 1、如果是两人私聊，则读取对方的头像和昵称，如果对方已认证则读取其认证信息
                $friend = $this->userModel->field(['user_id'])->where(['chat_group_id'=>$data['list'][$i]['id'],'user_id'=>['NEQ',$this->auth->id]])->find();
                $info = $this->sysUserModel
                    ->field(['nickname','realname','avatar'])
                    ->where(['id'=>$friend['user_id']])
                    ->find();
                $data['list'][$i]['group_name'] = $info['realname'];
                $data['list'][$i]['group_image'] = $info['avatar'];
                $data['list'][$i]['is_group'] = false;
            } else {
                // 2、如果是两人以上，则读取所有群成员头像和群名称
                $data['list'][$i]['group_name'] = '群聊';
                $data['list'][$i]['group_image'] = '/assets/img/avatar.png';
                $data['list'][$i]['is_group'] = true;
            }
            $last = $this->contentModel->field(['content'])->where(['chat_group_id'=>$data['list'][$i]['id']])->order(['id'=>'DESC'])->limit(1)->find();
            $data['list'][$i]['content'] = $last ? $last['content'] : '';
        }
        $this->success('请求成功',$data);
    }

    /**
     * 发起聊天
     * @param integer $user_id 用户ID
     * @return array
     */
    public function initChat()
    {
        $params = $this->request->param();
        $group = $this->userModel
            ->alias('a')
            ->field(['b.id'])
            ->join('__CHAT_GROUP__ b','a.chat_group_id=b.id')
            ->where(['b.user_id'=>$this->auth->id,'a.user_id'=>$params['user_id']])
            ->find();
        if ($group) {
            // 如果已有会话组，则直接获取
            $data['group_id'] = $group['id'];
        } else {
            // 否则创建会话组，并创建会话组成员
            $user = $this->sysUserModel
                ->field(['nickname','realname','avatar'])
                ->where(['id'=>$params['user_id']])
                ->find();
            $group_arr = [
                'user_id'   => $this->auth->id,
                'name'      => $user['nickname'],
                'thumbnail' => $user['avatar']
            ];
            $this->groupModel->save($group_arr);
            $group_users = [
                ['chat_group_id'=>$this->groupModel->id,'user_id'=>$this->auth->id],
                ['chat_group_id'=>$this->groupModel->id,'user_id'=>$params['user_id']]
            ];
            $this->userModel->saveAll($group_users);
            $data['group_id'] = $this->groupModel->id;
        }
        $this->success('请求成功',$data);
    }

    /**
     * 加载聊天记录
     * @param integer $group_id 会话组ID
     * @param integer $pages 页数
     * @param integer $limit 条数
     * @return array
     */
    public function getChatContent()
    {
        $params = $this->request->param();
        $limit = $params['limit'];
        $offset = ($params['pages']-1)*$limit;

        $data['list'] = $this->contentModel
            ->alias('a')
            ->field(['a.user_id','a.content as msg','a.createtime','b.nickname','b.realname','b.avatar'])
            ->join('__USER__ b','a.user_id=b.id')
            ->where(['a.chat_group_id'=>$params['group_id']])
            ->order(['a.id'=>'DESC'])
            ->limit($offset,$limit)
            ->select();
        $this->success('请求成功',$data);
    }
}</code></pre>
                <p>进入public/目录，执行以下代码以启动Workman</p>
<pre><code class="javascript">php server.php start // 以debug（调试模式）方式启动
php server.php start -d // 以daemon（守护进程）方式启动</code></pre>
                <p>注意，以调试模式启动时，所有错误会实时在控制台输出，且控制台关闭后连接也随着关闭了；以守护进程模式启动则错误信息不会显示，关闭控制台后连接仍然存在。</p>
                <p>至此，后端代码全部完成，下面接着是前端Vue代码，假设前端/pages/user/chat.vue是用户与用户（客服）的聊天窗口</p>
                <h3>四、初始化聊天连接</h3>
<pre><code class="javascript">// /pages/user/chat.vue
socketConnectInit() {
    this.socketTask = uni.connectSocket({
        url: 'ws://127.0.0.1:1236', // 即上面Index.php中定义的websocket地址，注意小程序中必须以wss开头
        method: 'GET',
        success(ret) {
            if (ret.errMsg == 'connectSocket:ok') {
                console.log("服务器正常")
            }
        }
    })
    this.socketTask.onOpen((res) => {
        this.isSocketOpen = true
        this.socketTask.send({
            data: JSON.stringify({
                type: 'authorize',
                user_id: this.userInfo.id
            }),
            async success() {
                console.log("鉴权成功")
            }
        })
        this.socketTask.onMessage((res) => {
            let ret = JSON.parse(res.data)
            let chatContent = {}
            switch (ret.type) {
                case 'heartbeat': // 心跳检测
                    break
                case 'notice': // 通知消息
                    chatContent = {
                        type: 'notice',
                        msg: ret.msg
                    }
                    this.chatList.push(chatContent)
                    break
                case 'message': // 聊天消息
                    chatContent = {
                        type: 'other',
                        user_id: ret.user_id,
                        avatar: ret.avatar,
                        msg: ret.msg,
                        createtime: new Date().getTime()
                    }
                    this.chatList.push(chatContent)
                    break
            }
            this.scrollToBottom()
        })
    })
    this.socketTask.onClose(() => {
        this.isSocketOpen = false
        this.scrollToBottom()
        console.log('监测到连接关闭')
    })
    clearInterval(this.pingpongTimes)
    this.pingpongTimes = setInterval(() => {
        this.socketTask.send({
            data: JSON.stringify({
                type: 'heartbeat',
                msg: 'ping'
            }),
            success: () => {},
            fail: () => {
                this.isSocketOpen = false
            }
        })
    }, 30000)
}</code></pre>
                <p>前端主要代码就写完了！</p>
                <h3>五、注意事项</h3>
                <p>1、用户每次连接会话，其都会产生新的client_id，类似于用户同时在手机、电脑上登录会有不同的token，但都是同一个人；</p>
                <p>2、本例实现了用户一对一聊天，其实跟多人群聊原理是一样的（会话组成员是2个和多个的区别），只不过前端对于2人私聊和群聊的UI逻辑不同；</p>
                <p>3、本例聊天可以发送聊天表情（表类型必须为utf8mb4），但并未实现发送聊天图片，可自行扩展；</p>
                <p>4、本例同时也集成了个推消息推送，这个是App才支持，下一篇专门来写App的消息推送；</p>
                <p>5、文章开始提到用户无需登录即可聊天实现的逻辑不一样，是因为业务需要保存用户聊天记录，希望用户下一次（可能N年后）再次进入聊天还能加载历史聊天记录，而如果是用户无需登录的临时聊天是无法长期保存的，即使保存起来也无法对应具体用户；</p>
                <p>6、由于涉及到的表比较多，本文只给出了基本的几个表结构，如需其他表结构或有问题要咨询可以通过底部QQ邮箱联系我（如果想挖我做CTO也欢迎，哈哈哈～～）。</p>
            </div>
        </div>
    </div>
    <footer class="footer mt-3 bg-dark">
        <div class="container pt-3 pb-3 text-light text-center">Copyright &copy;王维 2022 254555778@qq.com</div>
    </footer>
</body>
</html>